{
  "version": 3,
  "sources": ["../../../src/core/chat.ts", "../../../src/core/combat.ts", "../../../src/core/pathfinding.ts", "../../../src/core/character.ts", "../../../src/tasks/tutorial.ts", "../../../src/tasks/chicken.ts", "../../../src/core/client-detector.ts", "../../../src/core/pixel-detector.ts", "../../../src/core/game-interaction.ts", "../../../src/core/bot.ts"],
  "sourcesContent": ["export class ChatSystem {\n    private readonly noobPhrases = [\n        \"How do I train combat?\",\n        \"Where can I find chickens?\",\n        \"Anyone want to be friends?\",\n        \"I just started playing!\",\n        \"How do I make money?\",\n        \"This game is fun!\",\n        \"Can someone help me?\",\n        \"Where can I buy a sword?\",\n        \"How do I level up fast?\",\n        \"What should I do next?\"\n    ];\n\n    private readonly greetings = [\n        \"Hi!\",\n        \"Hello!\",\n        \"Hey there!\",\n        \"Sup!\",\n        \"Hi everyone!\"\n    ];\n\n    private readonly responses = [\n        \"Thanks for the help!\",\n        \"Oh cool, I didn't know that!\",\n        \"I'm still learning the game\",\n        \"This is my first time playing\",\n        \"That's awesome!\"\n    ];\n\n    private readonly questions = [\n        \"What level are you?\",\n        \"How long have you been playing?\",\n        \"What's the best way to make money?\",\n        \"Where should I train?\",\n        \"Can you show me around?\"\n    ];\n\n    private lastMessageTime: number = 0;\n    private readonly MESSAGE_COOLDOWN: number = 5000; // 5 seconds cooldown between messages\n\n    public generateGreeting(): string {\n        return this.getRandomPhrase(this.greetings);\n    }\n\n    public generateNoobChat(): string {\n        return this.getRandomPhrase(this.noobPhrases);\n    }\n\n    public generateResponse(): string {\n        return this.getRandomPhrase(this.responses);\n    }\n\n    public generateQuestion(): string {\n        return this.getRandomPhrase(this.questions);\n    }\n\n    public async sendMessage(message: string): Promise<void> {\n        const currentTime = Date.now();\n        if (currentTime - this.lastMessageTime >= this.MESSAGE_COOLDOWN) {\n            console.log(`[BOT] ${message}`);\n            this.lastMessageTime = currentTime;\n        }\n    }\n\n    public async handlePlayerDetected(): Promise<void> {\n        // 30% chance to initiate conversation when seeing another player\n        if (Math.random() < 0.3) {\n            const messageType = Math.random();\n            let message: string;\n\n            if (messageType < 0.3) {\n                message = this.generateGreeting();\n            } else if (messageType < 0.6) {\n                message = this.generateQuestion();\n            } else {\n                message = this.generateNoobChat();\n            }\n\n            await this.sendMessage(message);\n        }\n    }\n\n    private getRandomPhrase(phrases: string[]): string {\n        const index = Math.floor(Math.random() * phrases.length);\n        return phrases[index];\n    }\n}\n", "import { Position, NPC, Player } from '../types';\n\nexport class CombatSystem {\n    private readonly ATTACK_RANGE = 1; // Melee attack range\n    private readonly ATTACK_DELAY = 2400; // Attack speed in milliseconds\n    private lastAttackTime: number = 0;\n\n    constructor(private player: Player) {}\n\n    public async attackTarget(target: NPC): Promise<void> {\n        const currentTime = Date.now();\n        \n        // Check if we can attack again (cooldown)\n        if (currentTime - this.lastAttackTime < this.ATTACK_DELAY) {\n            return;\n        }\n\n        // Check if target is in range\n        if (this.isTargetInRange(target.position)) {\n            console.log(`Attacking ${target.name}`);\n            await this.performAttack(target);\n            this.lastAttackTime = currentTime;\n        } else {\n            console.log(`${target.name} is not in range`);\n        }\n    }\n\n    public async killChickens(): Promise<void> {\n        const chickenLocations = this.getLumbridgeChickenLocations();\n        \n        for (const location of chickenLocations) {\n            // Find nearest chicken\n            const chicken: NPC = {\n                id: 1,\n                name: 'Chicken',\n                position: location\n            };\n\n            // Attack chicken until dead\n            await this.attackTarget(chicken);\n            \n            // Collect feathers\n            await this.collectDrops(location);\n        }\n    }\n\n    public async trainSwordCombat(): Promise<void> {\n        // Train with sword on chickens for optimal xp\n        console.log('Training sword combat skills...');\n        \n        // Ensure we have a sword equipped\n        await this.checkEquipment();\n        \n        // Find and attack chickens\n        await this.killChickens();\n    }\n\n    private async performAttack(target: NPC): Promise<void> {\n        // Calculate hit chance and damage\n        const damage = this.calculateDamage();\n        console.log(`Hit ${target.name} for ${damage} damage`);\n    }\n\n    private calculateDamage(): number {\n        // Basic damage calculation based on stats and weapon\n        const baseMax = 4; // Basic sword max hit\n        return Math.floor(Math.random() * baseMax) + 1;\n    }\n\n    private isTargetInRange(targetPosition: Position): boolean {\n        const distance = this.calculateDistance(this.player.position, targetPosition);\n        if (distance > this.ATTACK_RANGE) {\n            // Move closer to target if not in range\n            this.moveTowardTarget(targetPosition);\n            return false;\n        }\n        return true;\n    }\n\n    private moveTowardTarget(targetPosition: Position): void {\n        // Calculate step toward target\n        const dx = targetPosition.x - this.player.position.x;\n        const dy = targetPosition.y - this.player.position.y;\n        \n        // Normalize movement to 1 tile at a time\n        const stepX = Math.sign(dx);\n        const stepY = Math.sign(dy);\n        \n        // Update player position\n        this.player.position = {\n            x: this.player.position.x + stepX,\n            y: this.player.position.y + stepY\n        };\n        \n        console.log(`Moving closer to target: ${this.player.position.x}, ${this.player.position.y}`);\n    }\n\n    private calculateDistance(pos1: Position, pos2: Position): number {\n        const dx = pos2.x - pos1.x;\n        const dy = pos2.y - pos1.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    private getLumbridgeChickenLocations(): Position[] {\n        // Known chicken locations in Lumbridge\n        return [\n            { x: 3235, y: 3295 }, // Behind Lumbridge Castle\n            { x: 3235, y: 3294 },\n            { x: 3236, y: 3296 },\n            { x: 3233, y: 3295 }\n        ];\n    }\n\n    private async checkEquipment(): Promise<void> {\n        // Check if sword is equipped\n        console.log('Checking equipment...');\n        // TODO: Implement equipment checking logic\n    }\n\n    private async collectDrops(position: Position): Promise<void> {\n        console.log('Collecting feathers...');\n        // TODO: Implement drop collection logic\n    }\n}\n", "import { Position } from '../types';\n\nexport class PathfindingSystem {\n    private readonly WALK_DELAY = 600; // Milliseconds between steps\n    private lastMoveTime: number = 0;\n\n    // Common locations\n    private readonly LOCATIONS = {\n        TUTORIAL_ISLAND: {\n            START: { x: 3098, y: 3107 },\n            GUIDE: { x: 3099, y: 3109 },\n            SURVIVAL_EXPERT: { x: 3106, y: 3115 },\n            COMBAT_AREA: { x: 3110, y: 3122 },\n            BANK: { x: 3120, y: 3124 }\n        },\n        LUMBRIDGE: {\n            SPAWN: { x: 3222, y: 3219 },\n            CHICKEN_COOP: { x: 3235, y: 3295 },\n            BANK: { x: 3208, y: 3220 }\n        }\n    };\n\n    constructor(private currentPosition: Position) {}\n\n    public async moveTo(destination: Position): Promise<void> {\n        const path = this.calculatePath(this.currentPosition, destination);\n        \n        for (const point of path) {\n            if (!await this.step(point)) {\n                console.log('Path blocked or unable to move');\n                break;\n            }\n        }\n    }\n\n    public async moveToTutorialSection(section: keyof typeof this.LOCATIONS.TUTORIAL_ISLAND): Promise<void> {\n        const destination = this.LOCATIONS.TUTORIAL_ISLAND[section];\n        await this.moveTo(destination);\n    }\n\n    public async moveToLumbridgeLocation(location: keyof typeof this.LOCATIONS.LUMBRIDGE): Promise<void> {\n        const destination = this.LOCATIONS.LUMBRIDGE[location];\n        await this.moveTo(destination);\n    }\n\n    private async step(position: Position): Promise<boolean> {\n        const currentTime = Date.now();\n        \n        // Respect walk delay\n        if (currentTime - this.lastMoveTime < this.WALK_DELAY) {\n            await this.wait(this.WALK_DELAY - (currentTime - this.lastMoveTime));\n        }\n\n        // Update position\n        this.currentPosition = position;\n        this.lastMoveTime = Date.now();\n        \n        console.log(`Moved to position: ${position.x}, ${position.y}`);\n        return true;\n    }\n\n    private calculatePath(start: Position, end: Position): Position[] {\n        // Simple A* pathfinding implementation\n        const path: Position[] = [];\n        \n        // For now, just return direct path\n        // TODO: Implement proper A* pathfinding with collision detection\n        const dx = end.x - start.x;\n        const dy = end.y - start.y;\n        const steps = Math.max(Math.abs(dx), Math.abs(dy));\n        \n        for (let i = 1; i <= steps; i++) {\n            path.push({\n                x: start.x + Math.floor((dx * i) / steps),\n                y: start.y + Math.floor((dy * i) / steps)\n            });\n        }\n        \n        return path;\n    }\n\n    private async wait(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    public getLocation(area: 'TUTORIAL_ISLAND' | 'LUMBRIDGE', location: string): Position {\n        return this.LOCATIONS[area][location as keyof typeof this.LOCATIONS[typeof area]];\n    }\n\n    public async navigateToNearestBank(): Promise<void> {\n        // Find and move to nearest bank\n        const nearestBank = this.findNearestBank();\n        await this.moveTo(nearestBank);\n    }\n\n    private findNearestBank(): Position {\n        // For now, just return Lumbridge bank\n        // TODO: Implement actual nearest bank calculation\n        return this.LOCATIONS.LUMBRIDGE.BANK;\n    }\n\n    public isAtLocation(position: Position, targetPosition: Position, tolerance: number = 1): boolean {\n        const dx = Math.abs(position.x - targetPosition.x);\n        const dy = Math.abs(position.y - targetPosition.y);\n        return dx <= tolerance && dy <= tolerance;\n    }\n}\n", "export interface CharacterAppearance {\n    gender: 'male';\n    head: number;\n    jaw: number;\n    torso: number;\n    arms: number;\n    hands: number;\n    legs: number;\n    feet: number;\n    hairColor: number;\n    torsoColor: number;\n    legsColor: number;\n    feetColor: number;\n    skinColor: number;\n}\n\nexport class CharacterCustomization {\n    // Valid style IDs for male characters\n    private static readonly MALE_STYLES = {\n        heads: [0, 1, 2, 3, 4, 5, 6, 7],\n        jaws: [0, 1, 2, 3, 4, 5, 6, 7],\n        torsos: [0, 1, 2, 3],\n        arms: [0, 1, 2, 3],\n        hands: [0],\n        legs: [0, 1, 2, 3],\n        feet: [0, 1, 2, 3]\n    };\n\n    // Valid color IDs\n    private static readonly COLORS = {\n        hair: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n        torso: [0, 1, 2, 3, 4, 5, 6, 7],\n        legs: [0, 1, 2, 3, 4, 5, 6, 7],\n        feet: [0, 1, 2, 3, 4],\n        skin: [0, 1, 2, 3, 4, 5, 6, 7]\n    };\n\n    public static generateRandomMaleAppearance(): CharacterAppearance {\n        return {\n            gender: 'male',\n            head: this.getRandomElement(this.MALE_STYLES.heads),\n            jaw: this.getRandomElement(this.MALE_STYLES.jaws),\n            torso: this.getRandomElement(this.MALE_STYLES.torsos),\n            arms: this.getRandomElement(this.MALE_STYLES.arms),\n            hands: this.getRandomElement(this.MALE_STYLES.hands),\n            legs: this.getRandomElement(this.MALE_STYLES.legs),\n            feet: this.getRandomElement(this.MALE_STYLES.feet),\n            hairColor: this.getRandomElement(this.COLORS.hair),\n            torsoColor: this.getRandomElement(this.COLORS.torso),\n            legsColor: this.getRandomElement(this.COLORS.legs),\n            feetColor: this.getRandomElement(this.COLORS.feet),\n            skinColor: this.getRandomElement(this.COLORS.skin)\n        };\n    }\n\n    private static getRandomElement<T>(array: T[]): T {\n        return array[Math.floor(Math.random() * array.length)];\n    }\n}\n", "import { Player } from '../types';\nimport { PathfindingSystem } from '../core/pathfinding';\nimport { ChatSystem } from '../core/chat';\nimport { CharacterCustomization, CharacterAppearance } from '../core/character';\n\nexport class TutorialIsland {\n    private pathfinding: PathfindingSystem;\n    private chat: ChatSystem;\n\n    constructor(private player: Player) {\n        this.pathfinding = new PathfindingSystem(player.position);\n        this.chat = new ChatSystem();\n    }\n\n    public async completeTutorial(): Promise<void> {\n        console.log('Starting Tutorial Island...');\n\n        try {\n            await this.characterCreation();\n            await this.meetGuide();\n            await this.survivalSection();\n            await this.cookingSection();\n            await this.questSection();\n            await this.miningSection();\n            await this.combatSection();\n            await this.bankSection();\n            await this.priestSection();\n            await this.wizardSection();\n            await this.finalSection();\n\n            console.log('Tutorial Island completed successfully!');\n        } catch (error) {\n            console.error('Error completing tutorial:', error);\n            throw error;\n        }\n    }\n\n    private async characterCreation(): Promise<void> {\n        console.log('Character creation...');\n        \n        // Generate random male appearance\n        const appearance = CharacterCustomization.generateRandomMaleAppearance();\n        console.log('Generated random male appearance:', appearance);\n        \n        // Apply appearance settings\n        await this.applyCharacterAppearance(appearance);\n        \n        // Confirm character creation\n        await this.wait(1000);\n    }\n\n    private async applyCharacterAppearance(appearance: CharacterAppearance): Promise<void> {\n        console.log('Applying character appearance...');\n        \n        // Set gender (male)\n        console.log('Setting gender: male');\n        \n        // Set head style\n        console.log(`Setting head style: ${appearance.head}`);\n        \n        // Set jaw style\n        console.log(`Setting jaw style: ${appearance.jaw}`);\n        \n        // Set torso style\n        console.log(`Setting torso style: ${appearance.torso}`);\n        \n        // Set arms style\n        console.log(`Setting arms style: ${appearance.arms}`);\n        \n        // Set hands style\n        console.log(`Setting hands style: ${appearance.hands}`);\n        \n        // Set legs style\n        console.log(`Setting legs style: ${appearance.legs}`);\n        \n        // Set feet style\n        console.log(`Setting feet style: ${appearance.feet}`);\n        \n        // Set colors\n        console.log(`Setting hair color: ${appearance.hairColor}`);\n        console.log(`Setting torso color: ${appearance.torsoColor}`);\n        console.log(`Setting legs color: ${appearance.legsColor}`);\n        console.log(`Setting feet color: ${appearance.feetColor}`);\n        console.log(`Setting skin color: ${appearance.skinColor}`);\n        \n        // Wait for appearance updates to apply\n        await this.wait(500);\n    }\n\n    private async meetGuide(): Promise<void> {\n        console.log('Meeting the guide...');\n        await this.pathfinding.moveToTutorialSection('GUIDE');\n        // Talk to guide dialogue\n        await this.wait(2000);\n    }\n\n    private async survivalSection(): Promise<void> {\n        console.log('Survival section...');\n        await this.pathfinding.moveToTutorialSection('SURVIVAL_EXPERT');\n        \n        // Fishing spot interaction\n        await this.wait(1000);\n        \n        // Make fire\n        await this.wait(1500);\n        \n        // Cook shrimps\n        await this.wait(2000);\n    }\n\n    private async cookingSection(): Promise<void> {\n        console.log('Cooking section...');\n        // Navigate to cooking area\n        await this.wait(1500);\n        \n        // Make bread\n        await this.wait(2000);\n    }\n\n    private async questSection(): Promise<void> {\n        console.log('Quest section...');\n        // Talk to quest guide\n        await this.wait(1500);\n        \n        // Open quest menu\n        await this.wait(1000);\n    }\n\n    private async miningSection(): Promise<void> {\n        console.log('Mining section...');\n        // Mine tin\n        await this.wait(2000);\n        \n        // Mine copper\n        await this.wait(2000);\n        \n        // Smelt bronze\n        await this.wait(2000);\n        \n        // Smith dagger\n        await this.wait(2000);\n    }\n\n    private async combatSection(): Promise<void> {\n        console.log('Combat section...');\n        await this.pathfinding.moveToTutorialSection('COMBAT_AREA');\n        \n        // Equip gear\n        await this.wait(1000);\n        \n        // Attack rat\n        await this.wait(3000);\n    }\n\n    private async bankSection(): Promise<void> {\n        console.log('Banking section...');\n        await this.pathfinding.moveToTutorialSection('BANK');\n        \n        // Open bank\n        await this.wait(1500);\n        \n        // Learn about PIN\n        await this.wait(1000);\n    }\n\n    private async priestSection(): Promise<void> {\n        console.log('Prayer section...');\n        // Visit church\n        await this.wait(2000);\n        \n        // Learn about prayer\n        await this.wait(1500);\n    }\n\n    private async wizardSection(): Promise<void> {\n        console.log('Magic section...');\n        // Learn about magic\n        await this.wait(2000);\n        \n        // Cast wind strike\n        await this.wait(1500);\n    }\n\n    private async finalSection(): Promise<void> {\n        console.log('Final section...');\n        // Final guide conversation\n        await this.wait(1500);\n        \n        // Complete tutorial\n        await this.wait(1000);\n    }\n\n    private async wait(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n}\n", "import { Player, Position } from '../types';\nimport { PathfindingSystem } from '../core/pathfinding';\nimport { CombatSystem } from '../core/combat';\nimport { ChatSystem } from '../core/chat';\n\nexport class ChickenTraining {\n    private pathfinding: PathfindingSystem;\n    private combat: CombatSystem;\n    private chat: ChatSystem;\n    private isTraining: boolean = false;\n\n    // Lumbridge chicken coop area boundaries and optimal positions\n    private readonly CHICKEN_AREA = {\n        minX: 3225,\n        maxX: 3236,\n        minY: 3285,\n        maxY: 3298,\n        // Optimal positions for chicken killing\n        positions: [\n            { x: 3233, y: 3295 }, // Center of chicken coop\n            { x: 3231, y: 3294 }, // Near fence\n            { x: 3235, y: 3293 }, // Near gate\n            { x: 3234, y: 3296 }  // Back corner\n        ]\n    };\n\n    private currentPositionIndex: number = 0;\n\n    constructor(private player: Player) {\n        this.pathfinding = new PathfindingSystem(player.position);\n        this.combat = new CombatSystem(player);\n        this.chat = new ChatSystem();\n    }\n\n    public async startTraining(): Promise<void> {\n        console.log('Starting chicken training routine...');\n        this.isTraining = true;\n\n        try {\n            // First, get to the chicken area\n            await this.goToChickenArea();\n\n            while (this.isTraining) {\n                // Main training loop\n                await this.trainOnChickens();\n                \n                // Check inventory\n                if (await this.isInventoryFull()) {\n                    await this.handleFullInventory();\n                }\n\n                // Chat disabled\n                // if (Math.random() < 0.1) { // 10% chance per loop\n                //     await this.sendRandomTrainingMessage();\n                // }\n\n                // Small delay between iterations\n                await this.wait(1000);\n            }\n        } catch (error) {\n            console.error('Error during chicken training:', error);\n            this.isTraining = false;\n            throw error;\n        }\n    }\n\n    public stopTraining(): void {\n        this.isTraining = false;\n        console.log('Stopping chicken training...');\n    }\n\n    private async goToChickenArea(): Promise<void> {\n        console.log('Moving to Lumbridge chicken coop...');\n        await this.pathfinding.moveToLumbridgeLocation('CHICKEN_COOP');\n    }\n\n    private async trainOnChickens(): Promise<void> {\n        // Move to next optimal position\n        const currentPosition = this.CHICKEN_AREA.positions[this.currentPositionIndex];\n        \n        // Move to position if not already there\n        if (!this.isAtPosition(this.player.position, currentPosition)) {\n            await this.pathfinding.moveTo(currentPosition);\n        }\n\n        // Find and attack chickens\n        await this.combat.killChickens();\n        \n        // Collect feathers and other drops\n        await this.collectDrops();\n\n        // Rotate through positions\n        this.currentPositionIndex = (this.currentPositionIndex + 1) % this.CHICKEN_AREA.positions.length;\n        \n        // Small delay before next position\n        await this.wait(500);\n    }\n\n    private isAtPosition(current: Position, target: Position, tolerance: number = 1): boolean {\n        return Math.abs(current.x - target.x) <= tolerance && \n               Math.abs(current.y - target.y) <= tolerance;\n    }\n\n    private async collectDrops(): Promise<void> {\n        console.log('Collecting drops...');\n        // Implement drop collection logic\n        await this.wait(500);\n    }\n\n    private async isInventoryFull(): Promise<boolean> {\n        // Check if inventory is full (28 slots)\n        return this.player.inventory.length >= 28;\n    }\n\n    private async handleFullInventory(): Promise<void> {\n        console.log('Inventory full, banking items...');\n        \n        // Go to Lumbridge bank\n        await this.pathfinding.moveToLumbridgeLocation('BANK');\n        \n        // Bank items\n        await this.bankItems();\n        \n        // Return to chicken area\n        await this.goToChickenArea();\n    }\n\n    private async bankItems(): Promise<void> {\n        console.log('Banking feathers and drops...');\n        // Implement banking logic\n        await this.wait(1000);\n    }\n\n    private async sendRandomTrainingMessage(): Promise<void> {\n        const trainingMessages = [\n            \"These chickens are great for training!\",\n            \"Anyone know where I can sell these feathers?\",\n            \"My combat skills are getting better!\",\n            \"This is a good spot for beginners like me\",\n            \"How many feathers should I collect?\"\n        ];\n\n        const message = trainingMessages[Math.floor(Math.random() * trainingMessages.length)];\n        await this.chat.sendMessage(message);\n    }\n\n    private isInChickenArea(position: Position): boolean {\n        return position.x >= this.CHICKEN_AREA.minX &&\n               position.x <= this.CHICKEN_AREA.maxX &&\n               position.y >= this.CHICKEN_AREA.minY &&\n               position.y <= this.CHICKEN_AREA.maxY;\n    }\n\n    private async wait(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n}\n", "import { Position } from '../types';\n\ninterface GameWindow {\n    title: string;\n    position: Position;\n    dimensions: {\n        width: number;\n        height: number;\n    };\n}\n\ninterface ClientBounds {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\nexport class GameClientDetector {\n    private static readonly CLIENT_TITLE = \"2004Scape\";\n    private static readonly DEFAULT_CLIENT_SIZE = {\n        width: 765,\n        height: 503\n    };\n\n    private gameWindow: GameWindow | null = null;\n    private isClientFound: boolean = false;\n    private checkInterval: any = null;\n    private isBrowserEnvironment: boolean;\n    private manualClientBounds: ClientBounds | null = null;\n\n    constructor() {\n        this.isBrowserEnvironment = typeof window !== 'undefined';\n        if (this.isBrowserEnvironment) {\n            // Try to load saved client bounds\n            const savedBounds = localStorage.getItem('gameClientBounds');\n            if (savedBounds) {\n                this.manualClientBounds = JSON.parse(savedBounds);\n            }\n            this.startDetection();\n        }\n    }\n\n    public async setClientBounds(bounds: ClientBounds): Promise<void> {\n        this.manualClientBounds = bounds;\n        localStorage.setItem('gameClientBounds', JSON.stringify(bounds));\n        \n        // Update game window with manual bounds\n        this.gameWindow = {\n            title: document.title,\n            position: {\n                x: bounds.x,\n                y: bounds.y\n            },\n            dimensions: {\n                width: bounds.width,\n                height: bounds.height\n            }\n        };\n        \n        this.isClientFound = true;\n        this.emitClientFound();\n    }\n\n    public startDetection(): void {\n        if (!this.isBrowserEnvironment) {\n            console.log('Client detection is only available in browser environment');\n            return;\n        }\n\n        if (this.checkInterval) {\n            return;\n        }\n\n        console.log('Starting game client detection...');\n        this.checkInterval = setInterval(() => this.detectClient(), 1000);\n    }\n\n    public stopDetection(): void {\n        if (this.checkInterval) {\n            clearInterval(this.checkInterval);\n            this.checkInterval = null;\n        }\n    }\n\n    private detectClient(): void {\n        if (!this.isBrowserEnvironment) return;\n\n        try {\n            // If we have manual bounds, use those\n            if (this.manualClientBounds) {\n                this.isClientFound = true;\n                this.gameWindow = {\n                    title: document.title,\n                    position: {\n                        x: this.manualClientBounds.x,\n                        y: this.manualClientBounds.y\n                    },\n                    dimensions: {\n                        width: this.manualClientBounds.width,\n                        height: this.manualClientBounds.height\n                    }\n                };\n                this.stopDetection();\n                this.emitClientFound();\n                return;\n            }\n\n            // Otherwise try automatic detection\n            const gameCanvas = document.querySelector('canvas');\n            if (gameCanvas && this.isGameClient(gameCanvas)) {\n                this.isClientFound = true;\n                this.gameWindow = {\n                    title: document.title,\n                    position: {\n                        x: window.screenX,\n                        y: window.screenY\n                    },\n                    dimensions: {\n                        width: gameCanvas.width,\n                        height: gameCanvas.height\n                    }\n                };\n                this.stopDetection();\n                this.emitClientFound();\n            }\n        } catch (error) {\n            console.error('Error detecting game client:', error);\n        }\n    }\n\n    private isGameClient(canvas: HTMLCanvasElement): boolean {\n        if (!this.isBrowserEnvironment) return false;\n\n        // Check if canvas dimensions match the game client\n        const matchesDimensions = \n            canvas.width === GameClientDetector.DEFAULT_CLIENT_SIZE.width &&\n            canvas.height === GameClientDetector.DEFAULT_CLIENT_SIZE.height;\n\n        // Check if title contains 2004Scape\n        const matchesTitle = document.title.includes(GameClientDetector.CLIENT_TITLE);\n\n        // Check for game-specific elements\n        const hasGameElements = this.checkForGameElements();\n\n        return matchesDimensions && matchesTitle && hasGameElements;\n    }\n\n    private checkForGameElements(): boolean {\n        if (!this.isBrowserEnvironment) return false;\n\n        // Check for specific game UI elements\n        const hasGameInterface = document.querySelector('#game-interface') !== null;\n        const hasMinimapArea = document.querySelector('#minimap-area') !== null;\n        const hasChatbox = document.querySelector('#chatbox-area') !== null;\n\n        // Check for game-specific URLs or resources\n        const isGameDomain = window.location.hostname.includes('2004.lostcity.rs');\n\n        return hasGameInterface || hasMinimapArea || hasChatbox || isGameDomain;\n    }\n\n    private emitClientFound(): void {\n        if (!this.isBrowserEnvironment) return;\n\n        const event = new CustomEvent('gameClientFound', {\n            detail: this.gameWindow\n        });\n        window.dispatchEvent(event);\n    }\n\n    public isClientDetected(): boolean {\n        return this.isClientFound;\n    }\n\n    public getGameWindow(): GameWindow | null {\n        return this.gameWindow;\n    }\n\n    public async waitForClient(timeout: number = 30000): Promise<GameWindow> {\n        if (!this.isBrowserEnvironment) {\n            return Promise.reject(new Error('Client detection is only available in browser environment'));\n        }\n\n        // If we already have manual bounds, use those immediately\n        if (this.manualClientBounds && this.gameWindow) {\n            return Promise.resolve(this.gameWindow);\n        }\n\n        return new Promise((resolve, reject) => {\n            if (this.isClientFound && this.gameWindow) {\n                resolve(this.gameWindow);\n                return;\n            }\n\n            const timeoutId = setTimeout(() => {\n                this.stopDetection();\n                // Open client selector if automatic detection fails\n                window.open('/client-selector', '_blank', 'width=800,height=600');\n                reject(new Error('Game client detection timed out. Please use manual selection.'));\n            }, timeout);\n\n            window.addEventListener('gameClientFound', ((event: CustomEvent) => {\n                clearTimeout(timeoutId);\n                resolve(event.detail);\n            }) as EventListener);\n\n            this.startDetection();\n        });\n    }\n}\n", "interface RGB {\n    r: number;\n    g: number;\n    b: number;\n}\n\ninterface PixelMatch {\n    x: number;\n    y: number;\n    confidence: number;\n}\n\nexport class PixelDetector {\n    private canvas: HTMLCanvasElement | null = null;\n    private ctx: CanvasRenderingContext2D | null = null;\n\n    constructor() {\n        if (typeof window !== 'undefined') {\n            this.canvas = document.createElement('canvas');\n            this.ctx = this.canvas.getContext('2d');\n        }\n    }\n\n    public async captureGameScreen(): Promise<ImageData | null> {\n        if (!this.canvas || !this.ctx) {\n            return null;\n        }\n\n        try {\n            const gameCanvas = document.querySelector('canvas');\n            if (!gameCanvas) {\n                return null;\n            }\n\n            // Set canvas size to match game window\n            this.canvas.width = gameCanvas.width;\n            this.canvas.height = gameCanvas.height;\n\n            // Draw game canvas to our canvas\n            this.ctx.drawImage(gameCanvas, 0, 0);\n\n            // Get image data\n            return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n        } catch (error) {\n            console.error('Error capturing game screen:', error);\n            return null;\n        }\n    }\n\n    public findColorMatch(imageData: ImageData, targetColor: RGB, tolerance: number = 5): PixelMatch[] {\n        const matches: PixelMatch[] = [];\n        const data = imageData.data;\n        const width = imageData.width;\n\n        for (let i = 0; i < data.length; i += 4) {\n            const r = data[i];\n            const g = data[i + 1];\n            const b = data[i + 2];\n\n            if (this.isColorMatch({ r, g, b }, targetColor, tolerance)) {\n                const pixelIndex = i / 4;\n                const x = pixelIndex % width;\n                const y = Math.floor(pixelIndex / width);\n                const confidence = this.calculateConfidence({ r, g, b }, targetColor);\n                matches.push({ x, y, confidence });\n            }\n        }\n\n        // Sort by confidence\n        return matches.sort((a, b) => b.confidence - a.confidence);\n    }\n\n    private isColorMatch(color1: RGB, color2: RGB, tolerance: number): boolean {\n        return Math.abs(color1.r - color2.r) <= tolerance &&\n               Math.abs(color1.g - color2.g) <= tolerance &&\n               Math.abs(color1.b - color2.b) <= tolerance;\n    }\n\n    private calculateConfidence(color1: RGB, color2: RGB): number {\n        const rDiff = Math.abs(color1.r - color2.r);\n        const gDiff = Math.abs(color1.g - color2.g);\n        const bDiff = Math.abs(color1.b - color2.b);\n        const maxDiff = 255 * 3;\n        const totalDiff = rDiff + gDiff + bDiff;\n        return 1 - (totalDiff / maxDiff);\n    }\n\n    // Game-specific color detection methods\n    public async findGameElements(): Promise<{[key: string]: PixelMatch[]}> {\n        const imageData = await this.captureGameScreen();\n        if (!imageData) {\n            return {};\n        }\n\n        return {\n            // Common UI elements\n            minimap: this.findColorMatch(imageData, { r: 0, g: 0, b: 0 }, 10), // Black border\n            chatbox: this.findColorMatch(imageData, { r: 65, g: 54, b: 38 }, 10), // Brown background\n            \n            // Game objects\n            chickens: this.findColorMatch(imageData, { r: 255, g: 255, b: 255 }, 15), // White feathers\n            feathers: this.findColorMatch(imageData, { r: 238, g: 238, b: 238 }, 10), // Ground items\n            \n            // Combat elements\n            healthBar: this.findColorMatch(imageData, { r: 255, g: 0, b: 0 }, 10), // Red health\n            attackOptions: this.findColorMatch(imageData, { r: 255, g: 255, b: 0 }, 10), // Yellow text\n        };\n    }\n\n    public async waitForGameElement(elementType: string, timeout: number = 5000): Promise<PixelMatch | null> {\n        const startTime = Date.now();\n        \n        while (Date.now() - startTime < timeout) {\n            const elements = await this.findGameElements();\n            const matches = elements[elementType] || [];\n            \n            if (matches.length > 0) {\n                return matches[0]; // Return the highest confidence match\n            }\n            \n            await new Promise(resolve => setTimeout(resolve, 100)); // Wait 100ms before next check\n        }\n        \n        return null; // Timeout reached\n    }\n}\n", "import { Position } from '../types';\nimport { GameClientDetector } from './client-detector';\nimport { PixelDetector } from './pixel-detector';\n\ninterface GameElement {\n    type: string;\n    position: Position;\n    confidence: number;\n}\n\nexport class GameInteraction {\n    private clientDetector: GameClientDetector;\n    private pixelDetector: PixelDetector;\n    private lastInteractionTime: number = 0;\n    private readonly MIN_INTERACTION_DELAY = 600; // Minimum delay between actions in ms\n\n    constructor() {\n        this.clientDetector = new GameClientDetector();\n        this.pixelDetector = new PixelDetector();\n    }\n\n    public async initialize(): Promise<void> {\n        await this.clientDetector.waitForClient();\n        console.log('Game client detected and ready for interaction');\n    }\n\n    public async findGameElement(elementType: string): Promise<GameElement | null> {\n        const element = await this.pixelDetector.waitForGameElement(elementType);\n        if (!element) {\n            return null;\n        }\n\n        return {\n            type: elementType,\n            position: { x: element.x, y: element.y },\n            confidence: element.confidence\n        };\n    }\n\n    public async clickGameElement(elementType: string, rightClick: boolean = false): Promise<boolean> {\n        const element = await this.findGameElement(elementType);\n        if (!element) {\n            console.log(`Could not find game element: ${elementType}`);\n            return false;\n        }\n\n        await this.enforceDelay();\n        await this.simulateMouseMovement(element.position);\n        await this.click(element.position, rightClick);\n        \n        return true;\n    }\n\n    private async simulateMouseMovement(target: Position): Promise<void> {\n        // Get current mouse position from game canvas\n        const canvas = document.querySelector('canvas');\n        if (!canvas) return;\n\n        const rect = canvas.getBoundingClientRect();\n        const currentX = rect.left + rect.width / 2;\n        const currentY = rect.top + rect.height / 2;\n\n        // Calculate path to target\n        const path = this.generateMousePath(\n            { x: currentX, y: currentY },\n            { x: target.x, y: target.y }\n        );\n\n        // Move mouse along path\n        for (const point of path) {\n            await this.moveMouse(point);\n            await this.wait(Math.random() * 10 + 5); // Small random delay\n        }\n    }\n\n    private generateMousePath(start: Position, end: Position): Position[] {\n        const path: Position[] = [];\n        const steps = 10; // Number of points in the path\n\n        for (let i = 0; i <= steps; i++) {\n            // Add some randomness to the path\n            const progress = i / steps;\n            const randomOffset = {\n                x: (Math.random() - 0.5) * 10,\n                y: (Math.random() - 0.5) * 10\n            };\n\n            path.push({\n                x: start.x + (end.x - start.x) * progress + randomOffset.x,\n                y: start.y + (end.y - start.y) * progress + randomOffset.y\n            });\n        }\n\n        return path;\n    }\n\n    private async moveMouse(position: Position): Promise<void> {\n        const event = new MouseEvent('mousemove', {\n            bubbles: true,\n            cancelable: true,\n            clientX: position.x,\n            clientY: position.y\n        });\n\n        const canvas = document.querySelector('canvas');\n        if (canvas) {\n            canvas.dispatchEvent(event);\n        }\n    }\n\n    private async click(position: Position, rightClick: boolean = false): Promise<void> {\n        const canvas = document.querySelector('canvas');\n        if (!canvas) return;\n\n        // Mouse down event\n        const downEvent = new MouseEvent(rightClick ? 'contextmenu' : 'mousedown', {\n            bubbles: true,\n            cancelable: true,\n            clientX: position.x,\n            clientY: position.y,\n            button: rightClick ? 2 : 0\n        });\n        canvas.dispatchEvent(downEvent);\n\n        // Small delay between down and up\n        await this.wait(50 + Math.random() * 50);\n\n        // Mouse up event\n        const upEvent = new MouseEvent('mouseup', {\n            bubbles: true,\n            cancelable: true,\n            clientX: position.x,\n            clientY: position.y,\n            button: rightClick ? 2 : 0\n        });\n        canvas.dispatchEvent(upEvent);\n    }\n\n    public async typeText(text: string): Promise<void> {\n        await this.enforceDelay();\n\n        for (const char of text) {\n            const keyDownEvent = new KeyboardEvent('keydown', {\n                key: char,\n                bubbles: true,\n                cancelable: true\n            });\n            document.dispatchEvent(keyDownEvent);\n\n            await this.wait(50 + Math.random() * 50);\n\n            const keyUpEvent = new KeyboardEvent('keyup', {\n                key: char,\n                bubbles: true,\n                cancelable: true\n            });\n            document.dispatchEvent(keyUpEvent);\n\n            await this.wait(50 + Math.random() * 100);\n        }\n    }\n\n    private async enforceDelay(): Promise<void> {\n        const now = Date.now();\n        const timeSinceLastInteraction = now - this.lastInteractionTime;\n        \n        if (timeSinceLastInteraction < this.MIN_INTERACTION_DELAY) {\n            await this.wait(this.MIN_INTERACTION_DELAY - timeSinceLastInteraction);\n        }\n        \n        this.lastInteractionTime = Date.now();\n    }\n\n    private async wait(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    // Game-specific interactions\n    public async attackNPC(npcType: string): Promise<boolean> {\n        return await this.clickGameElement(npcType, true);\n    }\n\n    public async collectGroundItem(itemType: string): Promise<boolean> {\n        return await this.clickGameElement(itemType);\n    }\n\n    public async navigateToLocation(location: Position): Promise<void> {\n        await this.enforceDelay();\n        const minimapScale = 3; // Conversion factor from game coords to minimap pixels\n        \n        // Calculate minimap position\n        const minimapElement = await this.findGameElement('minimap');\n        if (!minimapElement) {\n            throw new Error('Could not find minimap');\n        }\n\n        const minimapX = minimapElement.position.x + (location.x / minimapScale);\n        const minimapY = minimapElement.position.y + (location.y / minimapScale);\n\n        await this.click({ x: minimapX, y: minimapY }, false);\n    }\n\n    public async isPlayerMoving(): Promise<boolean> {\n        // Check if the player's position is changing\n        const initialPosition = await this.getCurrentPosition();\n        await this.wait(500);\n        const newPosition = await this.getCurrentPosition();\n\n        return initialPosition.x !== newPosition.x || initialPosition.y !== newPosition.y;\n    }\n\n    private async getCurrentPosition(): Promise<Position> {\n        // This would need to be implemented based on how the game exposes player position\n        // For now, return a dummy position\n        return { x: 0, y: 0 };\n    }\n}\n", "import { Player, Position } from '../types';\nimport { ChatSystem } from './chat';\nimport { CombatSystem } from './combat';\nimport { PathfindingSystem } from './pathfinding';\nimport { TutorialIsland } from '../tasks/tutorial';\nimport { ChickenTraining } from '../tasks/chicken';\nimport { GameClientDetector } from './client-detector';\nimport { GameInteraction } from './game-interaction';\nimport { PixelDetector } from './pixel-detector';\n\ninterface BotStats {\n    chickensKilled: number;\n    feathersCollected: number;\n}\n\nexport class RunescapeBot {\n    private player: Player;\n    private isRunning: boolean = false;\n    private chatSystem: ChatSystem;\n    private combatSystem: CombatSystem;\n    private pathfinding: PathfindingSystem;\n    private tutorialIsland: TutorialIsland;\n    private chickenTraining: ChickenTraining;\n    private clientDetector: GameClientDetector;\n    private gameInteraction: GameInteraction;\n    private pixelDetector: PixelDetector;\n    private stats: BotStats = {\n        chickensKilled: 0,\n        feathersCollected: 0\n    };\n    private eventCallback: ((eventName: string, data: any) => void) | null = null;\n\n    constructor() {\n        this.player = {\n            position: { x: 3098, y: 3107 }, // Tutorial Island starting position\n            inventory: [],\n            skills: {\n                attack: 1,\n                strength: 1,\n                defense: 1\n            }\n        };\n\n        // Initialize systems\n        this.chatSystem = new ChatSystem();\n        this.combatSystem = new CombatSystem(this.player);\n        this.pathfinding = new PathfindingSystem(this.player.position);\n        this.tutorialIsland = new TutorialIsland(this.player);\n        this.chickenTraining = new ChickenTraining(this.player);\n        this.clientDetector = new GameClientDetector();\n        this.gameInteraction = new GameInteraction();\n        this.pixelDetector = new PixelDetector();\n    }\n\n    public async start(): Promise<void> {\n        try {\n            // Initialize game interaction\n            this.emitEvent('progress', { message: 'Detecting game client...' });\n            await this.gameInteraction.initialize();\n            this.emitEvent('progress', { message: 'Game client detected!' });\n\n            // Verify we can interact with the game\n            const canInteract = await this.verifyGameInteraction();\n            if (!canInteract) {\n                throw new Error('Unable to interact with game client');\n            }\n\n            this.isRunning = true;\n            this.emitEvent('botStarted', {});\n            console.log('Bot started');\n\n            // Complete Tutorial Island\n            await this.completeTutorialIsland();\n\n            // Start chicken training\n            await this.startChickenTraining();\n\n        } catch (error) {\n            console.error('Bot error:', error);\n            this.emitEvent('botError', { error });\n            this.stop();\n        }\n    }\n\n    private async verifyGameInteraction(): Promise<boolean> {\n        try {\n            // Check for essential game elements\n            const gameElements = await this.pixelDetector.findGameElements();\n            const hasMinimapElement = gameElements.minimap && gameElements.minimap.length > 0;\n            const hasChatboxElement = gameElements.chatbox && gameElements.chatbox.length > 0;\n\n            if (!hasMinimapElement || !hasChatboxElement) {\n                console.error('Could not find essential game elements');\n                return false;\n            }\n\n            return true;\n        } catch (error) {\n            console.error('Error verifying game interaction:', error);\n            return false;\n        }\n    }\n\n    public stop(): void {\n        this.isRunning = false;\n        this.chickenTraining.stopTraining();\n        this.clientDetector.stopDetection();\n        this.emitEvent('botStopped', {});\n        console.log('Bot stopped');\n    }\n\n    private async completeTutorialIsland(): Promise<void> {\n        console.log('Starting Tutorial Island...');\n        this.emitEvent('progress', { message: 'Starting Tutorial Island...' });\n        \n        try {\n            // Tutorial island steps using game interaction\n            await this.handleTutorialIsland();\n            \n            this.emitEvent('progress', { message: 'Tutorial Island completed!' });\n            console.log('Tutorial Island completed!');\n        } catch (error) {\n            console.error('Error completing Tutorial Island:', error);\n            throw error;\n        }\n    }\n\n    private async handleTutorialIsland(): Promise<void> {\n        // Tutorial Island steps\n        const steps = [\n            { type: 'npc', name: 'Guide', dialogue: ['Yes, I want to play RuneScape.'] },\n            { type: 'npc', name: 'Survival Expert', dialogue: ['I want to learn survival skills.'] },\n            // Add more tutorial steps as needed\n        ];\n\n        for (const step of steps) {\n            if (!this.isRunning) break;\n\n            try {\n                await this.handleTutorialStep(step);\n            } catch (error) {\n                console.error(`Error in tutorial step:`, error);\n                throw error;\n            }\n        }\n    }\n\n    private async handleTutorialStep(step: any): Promise<void> {\n        switch (step.type) {\n            case 'npc':\n                await this.gameInteraction.clickGameElement(step.name);\n                await this.wait(1000);\n                for (const text of step.dialogue) {\n                    await this.gameInteraction.typeText(text + String.fromCharCode(13)); // Enter key\n                    await this.wait(500);\n                }\n                break;\n            // Add more step types as needed\n        }\n    }\n\n    private async startChickenTraining(): Promise<void> {\n        console.log('Starting chicken training...');\n        this.emitEvent('progress', { message: 'Starting chicken training...' });\n        \n        while (this.isRunning) {\n            try {\n                // Find and attack chickens\n                const chickenFound = await this.gameInteraction.attackNPC('chicken');\n                if (chickenFound) {\n                    await this.wait(3000); // Wait for combat\n                    \n                    // Collect feathers\n                    const feathersFound = await this.gameInteraction.collectGroundItem('feather');\n                    if (feathersFound) {\n                        this.incrementFeathersCollected();\n                    }\n                }\n                \n                await this.wait(500);\n            } catch (error) {\n                console.error('Error in chicken training:', error);\n                // Continue running but log the error\n            }\n        }\n    }\n\n    private async wait(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    // UI Integration Methods\n    public getStats(): BotStats {\n        return this.stats;\n    }\n\n    public getPlayer(): Player {\n        return this.player;\n    }\n\n    public isActive(): boolean {\n        return this.isRunning;\n    }\n\n    public setEventCallback(callback: (eventName: string, data: any) => void): void {\n        this.eventCallback = callback;\n    }\n\n    public emitEvent(eventName: string, data: any): void {\n        if (this.eventCallback) {\n            this.eventCallback(eventName, data);\n        }\n    }\n\n    // Stats tracking methods\n    public incrementChickensKilled(): void {\n        this.stats.chickensKilled++;\n        this.emitEvent('statsUpdate', { stats: this.stats });\n    }\n\n    public incrementFeathersCollected(count: number = 1): void {\n        this.stats.feathersCollected += count;\n        this.emitEvent('statsUpdate', { stats: this.stats });\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
