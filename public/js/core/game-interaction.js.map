{
  "version": 3,
  "sources": ["../../../src/core/client-detector.ts", "../../../src/core/pixel-detector.ts", "../../../src/core/game-interaction.ts"],
  "sourcesContent": ["import { Position } from '../types';\n\ninterface GameWindow {\n    title: string;\n    position: Position;\n    dimensions: {\n        width: number;\n        height: number;\n    };\n}\n\ninterface ClientBounds {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\nexport class GameClientDetector {\n    private static readonly CLIENT_TITLE = \"2004Scape\";\n    private static readonly DEFAULT_CLIENT_SIZE = {\n        width: 765,\n        height: 503\n    };\n\n    private gameWindow: GameWindow | null = null;\n    private isClientFound: boolean = false;\n    private checkInterval: any = null;\n    private isBrowserEnvironment: boolean;\n    private manualClientBounds: ClientBounds | null = null;\n\n    constructor() {\n        this.isBrowserEnvironment = typeof window !== 'undefined';\n        if (this.isBrowserEnvironment) {\n            // Try to load saved client bounds\n            const savedBounds = localStorage.getItem('gameClientBounds');\n            if (savedBounds) {\n                this.manualClientBounds = JSON.parse(savedBounds);\n            }\n            this.startDetection();\n        }\n    }\n\n    public async setClientBounds(bounds: ClientBounds): Promise<void> {\n        this.manualClientBounds = bounds;\n        localStorage.setItem('gameClientBounds', JSON.stringify(bounds));\n        \n        // Update game window with manual bounds\n        this.gameWindow = {\n            title: document.title,\n            position: {\n                x: bounds.x,\n                y: bounds.y\n            },\n            dimensions: {\n                width: bounds.width,\n                height: bounds.height\n            }\n        };\n        \n        this.isClientFound = true;\n        this.emitClientFound();\n    }\n\n    public startDetection(): void {\n        if (!this.isBrowserEnvironment) {\n            console.log('Client detection is only available in browser environment');\n            return;\n        }\n\n        if (this.checkInterval) {\n            return;\n        }\n\n        console.log('Starting game client detection...');\n        this.checkInterval = setInterval(() => this.detectClient(), 1000);\n    }\n\n    public stopDetection(): void {\n        if (this.checkInterval) {\n            clearInterval(this.checkInterval);\n            this.checkInterval = null;\n        }\n    }\n\n    private detectClient(): void {\n        if (!this.isBrowserEnvironment) return;\n\n        try {\n            // If we have manual bounds, use those\n            if (this.manualClientBounds) {\n                this.isClientFound = true;\n                this.gameWindow = {\n                    title: document.title,\n                    position: {\n                        x: this.manualClientBounds.x,\n                        y: this.manualClientBounds.y\n                    },\n                    dimensions: {\n                        width: this.manualClientBounds.width,\n                        height: this.manualClientBounds.height\n                    }\n                };\n                this.stopDetection();\n                this.emitClientFound();\n                return;\n            }\n\n            // Otherwise try automatic detection\n            const gameCanvas = document.querySelector('canvas');\n            if (gameCanvas && this.isGameClient(gameCanvas)) {\n                this.isClientFound = true;\n                this.gameWindow = {\n                    title: document.title,\n                    position: {\n                        x: window.screenX,\n                        y: window.screenY\n                    },\n                    dimensions: {\n                        width: gameCanvas.width,\n                        height: gameCanvas.height\n                    }\n                };\n                this.stopDetection();\n                this.emitClientFound();\n            }\n        } catch (error) {\n            console.error('Error detecting game client:', error);\n        }\n    }\n\n    private isGameClient(canvas: HTMLCanvasElement): boolean {\n        if (!this.isBrowserEnvironment) return false;\n\n        // Check if canvas dimensions match the game client\n        const matchesDimensions = \n            canvas.width === GameClientDetector.DEFAULT_CLIENT_SIZE.width &&\n            canvas.height === GameClientDetector.DEFAULT_CLIENT_SIZE.height;\n\n        // Check if title contains 2004Scape\n        const matchesTitle = document.title.includes(GameClientDetector.CLIENT_TITLE);\n\n        // Check for game-specific elements\n        const hasGameElements = this.checkForGameElements();\n\n        return matchesDimensions && matchesTitle && hasGameElements;\n    }\n\n    private checkForGameElements(): boolean {\n        if (!this.isBrowserEnvironment) return false;\n\n        // Check for specific game UI elements\n        const hasGameInterface = document.querySelector('#game-interface') !== null;\n        const hasMinimapArea = document.querySelector('#minimap-area') !== null;\n        const hasChatbox = document.querySelector('#chatbox-area') !== null;\n\n        // Check for game-specific URLs or resources\n        const isGameDomain = window.location.hostname.includes('2004.lostcity.rs');\n\n        return hasGameInterface || hasMinimapArea || hasChatbox || isGameDomain;\n    }\n\n    private emitClientFound(): void {\n        if (!this.isBrowserEnvironment) return;\n\n        const event = new CustomEvent('gameClientFound', {\n            detail: this.gameWindow\n        });\n        window.dispatchEvent(event);\n    }\n\n    public isClientDetected(): boolean {\n        return this.isClientFound;\n    }\n\n    public getGameWindow(): GameWindow | null {\n        return this.gameWindow;\n    }\n\n    public async waitForClient(timeout: number = 30000): Promise<GameWindow> {\n        if (!this.isBrowserEnvironment) {\n            return Promise.reject(new Error('Client detection is only available in browser environment'));\n        }\n\n        // If we already have manual bounds, use those immediately\n        if (this.manualClientBounds && this.gameWindow) {\n            return Promise.resolve(this.gameWindow);\n        }\n\n        return new Promise((resolve, reject) => {\n            if (this.isClientFound && this.gameWindow) {\n                resolve(this.gameWindow);\n                return;\n            }\n\n            const timeoutId = setTimeout(() => {\n                this.stopDetection();\n                // Open client selector if automatic detection fails\n                window.open('/client-selector', '_blank', 'width=800,height=600');\n                reject(new Error('Game client detection timed out. Please use manual selection.'));\n            }, timeout);\n\n            window.addEventListener('gameClientFound', ((event: CustomEvent) => {\n                clearTimeout(timeoutId);\n                resolve(event.detail);\n            }) as EventListener);\n\n            this.startDetection();\n        });\n    }\n}\n", "interface RGB {\n    r: number;\n    g: number;\n    b: number;\n}\n\ninterface PixelMatch {\n    x: number;\n    y: number;\n    confidence: number;\n}\n\nexport class PixelDetector {\n    private canvas: HTMLCanvasElement | null = null;\n    private ctx: CanvasRenderingContext2D | null = null;\n\n    constructor() {\n        if (typeof window !== 'undefined') {\n            this.canvas = document.createElement('canvas');\n            this.ctx = this.canvas.getContext('2d');\n        }\n    }\n\n    public async captureGameScreen(): Promise<ImageData | null> {\n        if (!this.canvas || !this.ctx) {\n            return null;\n        }\n\n        try {\n            const gameCanvas = document.querySelector('canvas');\n            if (!gameCanvas) {\n                return null;\n            }\n\n            // Set canvas size to match game window\n            this.canvas.width = gameCanvas.width;\n            this.canvas.height = gameCanvas.height;\n\n            // Draw game canvas to our canvas\n            this.ctx.drawImage(gameCanvas, 0, 0);\n\n            // Get image data\n            return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n        } catch (error) {\n            console.error('Error capturing game screen:', error);\n            return null;\n        }\n    }\n\n    public findColorMatch(imageData: ImageData, targetColor: RGB, tolerance: number = 5): PixelMatch[] {\n        const matches: PixelMatch[] = [];\n        const data = imageData.data;\n        const width = imageData.width;\n\n        for (let i = 0; i < data.length; i += 4) {\n            const r = data[i];\n            const g = data[i + 1];\n            const b = data[i + 2];\n\n            if (this.isColorMatch({ r, g, b }, targetColor, tolerance)) {\n                const pixelIndex = i / 4;\n                const x = pixelIndex % width;\n                const y = Math.floor(pixelIndex / width);\n                const confidence = this.calculateConfidence({ r, g, b }, targetColor);\n                matches.push({ x, y, confidence });\n            }\n        }\n\n        // Sort by confidence\n        return matches.sort((a, b) => b.confidence - a.confidence);\n    }\n\n    private isColorMatch(color1: RGB, color2: RGB, tolerance: number): boolean {\n        return Math.abs(color1.r - color2.r) <= tolerance &&\n               Math.abs(color1.g - color2.g) <= tolerance &&\n               Math.abs(color1.b - color2.b) <= tolerance;\n    }\n\n    private calculateConfidence(color1: RGB, color2: RGB): number {\n        const rDiff = Math.abs(color1.r - color2.r);\n        const gDiff = Math.abs(color1.g - color2.g);\n        const bDiff = Math.abs(color1.b - color2.b);\n        const maxDiff = 255 * 3;\n        const totalDiff = rDiff + gDiff + bDiff;\n        return 1 - (totalDiff / maxDiff);\n    }\n\n    // Game-specific color detection methods\n    public async findGameElements(): Promise<{[key: string]: PixelMatch[]}> {\n        const imageData = await this.captureGameScreen();\n        if (!imageData) {\n            return {};\n        }\n\n        return {\n            // Common UI elements\n            minimap: this.findColorMatch(imageData, { r: 0, g: 0, b: 0 }, 10), // Black border\n            chatbox: this.findColorMatch(imageData, { r: 65, g: 54, b: 38 }, 10), // Brown background\n            \n            // Game objects\n            chickens: this.findColorMatch(imageData, { r: 255, g: 255, b: 255 }, 15), // White feathers\n            feathers: this.findColorMatch(imageData, { r: 238, g: 238, b: 238 }, 10), // Ground items\n            \n            // Combat elements\n            healthBar: this.findColorMatch(imageData, { r: 255, g: 0, b: 0 }, 10), // Red health\n            attackOptions: this.findColorMatch(imageData, { r: 255, g: 255, b: 0 }, 10), // Yellow text\n        };\n    }\n\n    public async waitForGameElement(elementType: string, timeout: number = 5000): Promise<PixelMatch | null> {\n        const startTime = Date.now();\n        \n        while (Date.now() - startTime < timeout) {\n            const elements = await this.findGameElements();\n            const matches = elements[elementType] || [];\n            \n            if (matches.length > 0) {\n                return matches[0]; // Return the highest confidence match\n            }\n            \n            await new Promise(resolve => setTimeout(resolve, 100)); // Wait 100ms before next check\n        }\n        \n        return null; // Timeout reached\n    }\n}\n", "import { Position } from '../types';\nimport { GameClientDetector } from './client-detector';\nimport { PixelDetector } from './pixel-detector';\n\ninterface GameElement {\n    type: string;\n    position: Position;\n    confidence: number;\n}\n\nexport class GameInteraction {\n    private clientDetector: GameClientDetector;\n    private pixelDetector: PixelDetector;\n    private lastInteractionTime: number = 0;\n    private readonly MIN_INTERACTION_DELAY = 600; // Minimum delay between actions in ms\n\n    constructor() {\n        this.clientDetector = new GameClientDetector();\n        this.pixelDetector = new PixelDetector();\n    }\n\n    public async initialize(): Promise<void> {\n        await this.clientDetector.waitForClient();\n        console.log('Game client detected and ready for interaction');\n    }\n\n    public async findGameElement(elementType: string): Promise<GameElement | null> {\n        const element = await this.pixelDetector.waitForGameElement(elementType);\n        if (!element) {\n            return null;\n        }\n\n        return {\n            type: elementType,\n            position: { x: element.x, y: element.y },\n            confidence: element.confidence\n        };\n    }\n\n    public async clickGameElement(elementType: string, rightClick: boolean = false): Promise<boolean> {\n        const element = await this.findGameElement(elementType);\n        if (!element) {\n            console.log(`Could not find game element: ${elementType}`);\n            return false;\n        }\n\n        await this.enforceDelay();\n        await this.simulateMouseMovement(element.position);\n        await this.click(element.position, rightClick);\n        \n        return true;\n    }\n\n    private async simulateMouseMovement(target: Position): Promise<void> {\n        // Get current mouse position from game canvas\n        const canvas = document.querySelector('canvas');\n        if (!canvas) return;\n\n        const rect = canvas.getBoundingClientRect();\n        const currentX = rect.left + rect.width / 2;\n        const currentY = rect.top + rect.height / 2;\n\n        // Calculate path to target\n        const path = this.generateMousePath(\n            { x: currentX, y: currentY },\n            { x: target.x, y: target.y }\n        );\n\n        // Move mouse along path\n        for (const point of path) {\n            await this.moveMouse(point);\n            await this.wait(Math.random() * 10 + 5); // Small random delay\n        }\n    }\n\n    private generateMousePath(start: Position, end: Position): Position[] {\n        const path: Position[] = [];\n        const steps = 10; // Number of points in the path\n\n        for (let i = 0; i <= steps; i++) {\n            // Add some randomness to the path\n            const progress = i / steps;\n            const randomOffset = {\n                x: (Math.random() - 0.5) * 10,\n                y: (Math.random() - 0.5) * 10\n            };\n\n            path.push({\n                x: start.x + (end.x - start.x) * progress + randomOffset.x,\n                y: start.y + (end.y - start.y) * progress + randomOffset.y\n            });\n        }\n\n        return path;\n    }\n\n    private async moveMouse(position: Position): Promise<void> {\n        const event = new MouseEvent('mousemove', {\n            bubbles: true,\n            cancelable: true,\n            clientX: position.x,\n            clientY: position.y\n        });\n\n        const canvas = document.querySelector('canvas');\n        if (canvas) {\n            canvas.dispatchEvent(event);\n        }\n    }\n\n    private async click(position: Position, rightClick: boolean = false): Promise<void> {\n        const canvas = document.querySelector('canvas');\n        if (!canvas) return;\n\n        // Mouse down event\n        const downEvent = new MouseEvent(rightClick ? 'contextmenu' : 'mousedown', {\n            bubbles: true,\n            cancelable: true,\n            clientX: position.x,\n            clientY: position.y,\n            button: rightClick ? 2 : 0\n        });\n        canvas.dispatchEvent(downEvent);\n\n        // Small delay between down and up\n        await this.wait(50 + Math.random() * 50);\n\n        // Mouse up event\n        const upEvent = new MouseEvent('mouseup', {\n            bubbles: true,\n            cancelable: true,\n            clientX: position.x,\n            clientY: position.y,\n            button: rightClick ? 2 : 0\n        });\n        canvas.dispatchEvent(upEvent);\n    }\n\n    public async typeText(text: string): Promise<void> {\n        await this.enforceDelay();\n\n        for (const char of text) {\n            const keyDownEvent = new KeyboardEvent('keydown', {\n                key: char,\n                bubbles: true,\n                cancelable: true\n            });\n            document.dispatchEvent(keyDownEvent);\n\n            await this.wait(50 + Math.random() * 50);\n\n            const keyUpEvent = new KeyboardEvent('keyup', {\n                key: char,\n                bubbles: true,\n                cancelable: true\n            });\n            document.dispatchEvent(keyUpEvent);\n\n            await this.wait(50 + Math.random() * 100);\n        }\n    }\n\n    private async enforceDelay(): Promise<void> {\n        const now = Date.now();\n        const timeSinceLastInteraction = now - this.lastInteractionTime;\n        \n        if (timeSinceLastInteraction < this.MIN_INTERACTION_DELAY) {\n            await this.wait(this.MIN_INTERACTION_DELAY - timeSinceLastInteraction);\n        }\n        \n        this.lastInteractionTime = Date.now();\n    }\n\n    private async wait(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    // Game-specific interactions\n    public async attackNPC(npcType: string): Promise<boolean> {\n        return await this.clickGameElement(npcType, true);\n    }\n\n    public async collectGroundItem(itemType: string): Promise<boolean> {\n        return await this.clickGameElement(itemType);\n    }\n\n    public async navigateToLocation(location: Position): Promise<void> {\n        await this.enforceDelay();\n        const minimapScale = 3; // Conversion factor from game coords to minimap pixels\n        \n        // Calculate minimap position\n        const minimapElement = await this.findGameElement('minimap');\n        if (!minimapElement) {\n            throw new Error('Could not find minimap');\n        }\n\n        const minimapX = minimapElement.position.x + (location.x / minimapScale);\n        const minimapY = minimapElement.position.y + (location.y / minimapScale);\n\n        await this.click({ x: minimapX, y: minimapY }, false);\n    }\n\n    public async isPlayerMoving(): Promise<boolean> {\n        // Check if the player's position is changing\n        const initialPosition = await this.getCurrentPosition();\n        await this.wait(500);\n        const newPosition = await this.getCurrentPosition();\n\n        return initialPosition.x !== newPosition.x || initialPosition.y !== newPosition.y;\n    }\n\n    private async getCurrentPosition(): Promise<Position> {\n        // This would need to be implemented based on how the game exposes player position\n        // For now, return a dummy position\n        return { x: 0, y: 0 };\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
