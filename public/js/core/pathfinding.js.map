{
  "version": 3,
  "sources": ["../../../src/core/pathfinding.ts"],
  "sourcesContent": ["import { Position } from '../types';\n\nexport class PathfindingSystem {\n    private readonly WALK_DELAY = 600; // Milliseconds between steps\n    private lastMoveTime: number = 0;\n\n    // Common locations\n    private readonly LOCATIONS = {\n        TUTORIAL_ISLAND: {\n            START: { x: 3098, y: 3107 },\n            GUIDE: { x: 3099, y: 3109 },\n            SURVIVAL_EXPERT: { x: 3106, y: 3115 },\n            COMBAT_AREA: { x: 3110, y: 3122 },\n            BANK: { x: 3120, y: 3124 }\n        },\n        LUMBRIDGE: {\n            SPAWN: { x: 3222, y: 3219 },\n            CHICKEN_COOP: { x: 3235, y: 3295 },\n            BANK: { x: 3208, y: 3220 }\n        }\n    };\n\n    constructor(private currentPosition: Position) {}\n\n    public async moveTo(destination: Position): Promise<void> {\n        const path = this.calculatePath(this.currentPosition, destination);\n        \n        for (const point of path) {\n            if (!await this.step(point)) {\n                console.log('Path blocked or unable to move');\n                break;\n            }\n        }\n    }\n\n    public async moveToTutorialSection(section: keyof typeof this.LOCATIONS.TUTORIAL_ISLAND): Promise<void> {\n        const destination = this.LOCATIONS.TUTORIAL_ISLAND[section];\n        await this.moveTo(destination);\n    }\n\n    public async moveToLumbridgeLocation(location: keyof typeof this.LOCATIONS.LUMBRIDGE): Promise<void> {\n        const destination = this.LOCATIONS.LUMBRIDGE[location];\n        await this.moveTo(destination);\n    }\n\n    private async step(position: Position): Promise<boolean> {\n        const currentTime = Date.now();\n        \n        // Respect walk delay\n        if (currentTime - this.lastMoveTime < this.WALK_DELAY) {\n            await this.wait(this.WALK_DELAY - (currentTime - this.lastMoveTime));\n        }\n\n        // Update position\n        this.currentPosition = position;\n        this.lastMoveTime = Date.now();\n        \n        console.log(`Moved to position: ${position.x}, ${position.y}`);\n        return true;\n    }\n\n    private calculatePath(start: Position, end: Position): Position[] {\n        // Simple A* pathfinding implementation\n        const path: Position[] = [];\n        \n        // For now, just return direct path\n        // TODO: Implement proper A* pathfinding with collision detection\n        const dx = end.x - start.x;\n        const dy = end.y - start.y;\n        const steps = Math.max(Math.abs(dx), Math.abs(dy));\n        \n        for (let i = 1; i <= steps; i++) {\n            path.push({\n                x: start.x + Math.floor((dx * i) / steps),\n                y: start.y + Math.floor((dy * i) / steps)\n            });\n        }\n        \n        return path;\n    }\n\n    private async wait(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    public getLocation(area: 'TUTORIAL_ISLAND' | 'LUMBRIDGE', location: string): Position {\n        return this.LOCATIONS[area][location as keyof typeof this.LOCATIONS[typeof area]];\n    }\n\n    public async navigateToNearestBank(): Promise<void> {\n        // Find and move to nearest bank\n        const nearestBank = this.findNearestBank();\n        await this.moveTo(nearestBank);\n    }\n\n    private findNearestBank(): Position {\n        // For now, just return Lumbridge bank\n        // TODO: Implement actual nearest bank calculation\n        return this.LOCATIONS.LUMBRIDGE.BANK;\n    }\n\n    public isAtLocation(position: Position, targetPosition: Position, tolerance: number = 1): boolean {\n        const dx = Math.abs(position.x - targetPosition.x);\n        const dy = Math.abs(position.y - targetPosition.y);\n        return dx <= tolerance && dy <= tolerance;\n    }\n}\n"],
  "mappings": ";AAEO,IAAM,oBAAN,MAAwB;AAAA,EAoB3B,YAAoB,iBAA2B;AAA3B;AAnBpB,SAAiB,aAAa;AAC9B;AAAA,SAAQ,eAAuB;AAG/B;AAAA,SAAiB,YAAY;AAAA,MACzB,iBAAiB;AAAA,QACb,OAAO,EAAE,GAAG,MAAM,GAAG,KAAK;AAAA,QAC1B,OAAO,EAAE,GAAG,MAAM,GAAG,KAAK;AAAA,QAC1B,iBAAiB,EAAE,GAAG,MAAM,GAAG,KAAK;AAAA,QACpC,aAAa,EAAE,GAAG,MAAM,GAAG,KAAK;AAAA,QAChC,MAAM,EAAE,GAAG,MAAM,GAAG,KAAK;AAAA,MAC7B;AAAA,MACA,WAAW;AAAA,QACP,OAAO,EAAE,GAAG,MAAM,GAAG,KAAK;AAAA,QAC1B,cAAc,EAAE,GAAG,MAAM,GAAG,KAAK;AAAA,QACjC,MAAM,EAAE,GAAG,MAAM,GAAG,KAAK;AAAA,MAC7B;AAAA,IACJ;AAAA,EAEgD;AAAA,EAEhD,MAAa,OAAO,aAAsC;AACtD,UAAM,OAAO,KAAK,cAAc,KAAK,iBAAiB,WAAW;AAEjE,eAAW,SAAS,MAAM;AACtB,UAAI,CAAC,MAAM,KAAK,KAAK,KAAK,GAAG;AACzB,gBAAQ,IAAI,gCAAgC;AAC5C;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAa,sBAAsB,SAAqE;AACpG,UAAM,cAAc,KAAK,UAAU,gBAAgB,OAAO;AAC1D,UAAM,KAAK,OAAO,WAAW;AAAA,EACjC;AAAA,EAEA,MAAa,wBAAwB,UAAgE;AACjG,UAAM,cAAc,KAAK,UAAU,UAAU,QAAQ;AACrD,UAAM,KAAK,OAAO,WAAW;AAAA,EACjC;AAAA,EAEA,MAAc,KAAK,UAAsC;AACrD,UAAM,cAAc,KAAK,IAAI;AAG7B,QAAI,cAAc,KAAK,eAAe,KAAK,YAAY;AACnD,YAAM,KAAK,KAAK,KAAK,cAAc,cAAc,KAAK,aAAa;AAAA,IACvE;AAGA,SAAK,kBAAkB;AACvB,SAAK,eAAe,KAAK,IAAI;AAE7B,YAAQ,IAAI,sBAAsB,SAAS,CAAC,KAAK,SAAS,CAAC,EAAE;AAC7D,WAAO;AAAA,EACX;AAAA,EAEQ,cAAc,OAAiB,KAA2B;AAE9D,UAAM,OAAmB,CAAC;AAI1B,UAAM,KAAK,IAAI,IAAI,MAAM;AACzB,UAAM,KAAK,IAAI,IAAI,MAAM;AACzB,UAAM,QAAQ,KAAK,IAAI,KAAK,IAAI,EAAE,GAAG,KAAK,IAAI,EAAE,CAAC;AAEjD,aAAS,IAAI,GAAG,KAAK,OAAO,KAAK;AAC7B,WAAK,KAAK;AAAA,QACN,GAAG,MAAM,IAAI,KAAK,MAAO,KAAK,IAAK,KAAK;AAAA,QACxC,GAAG,MAAM,IAAI,KAAK,MAAO,KAAK,IAAK,KAAK;AAAA,MAC5C,CAAC;AAAA,IACL;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,MAAc,KAAK,IAA2B;AAC1C,WAAO,IAAI,QAAQ,aAAW,WAAW,SAAS,EAAE,CAAC;AAAA,EACzD;AAAA,EAEO,YAAY,MAAuC,UAA4B;AAClF,WAAO,KAAK,UAAU,IAAI,EAAE,QAAoD;AAAA,EACpF;AAAA,EAEA,MAAa,wBAAuC;AAEhD,UAAM,cAAc,KAAK,gBAAgB;AACzC,UAAM,KAAK,OAAO,WAAW;AAAA,EACjC;AAAA,EAEQ,kBAA4B;AAGhC,WAAO,KAAK,UAAU,UAAU;AAAA,EACpC;AAAA,EAEO,aAAa,UAAoB,gBAA0B,YAAoB,GAAY;AAC9F,UAAM,KAAK,KAAK,IAAI,SAAS,IAAI,eAAe,CAAC;AACjD,UAAM,KAAK,KAAK,IAAI,SAAS,IAAI,eAAe,CAAC;AACjD,WAAO,MAAM,aAAa,MAAM;AAAA,EACpC;AACJ;",
  "names": []
}
