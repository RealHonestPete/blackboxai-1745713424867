{
  "version": 3,
  "sources": ["../../../src/core/pixel-detector.ts"],
  "sourcesContent": ["interface RGB {\n    r: number;\n    g: number;\n    b: number;\n}\n\ninterface PixelMatch {\n    x: number;\n    y: number;\n    confidence: number;\n}\n\nexport class PixelDetector {\n    private canvas: HTMLCanvasElement | null = null;\n    private ctx: CanvasRenderingContext2D | null = null;\n\n    constructor() {\n        if (typeof window !== 'undefined') {\n            this.canvas = document.createElement('canvas');\n            this.ctx = this.canvas.getContext('2d');\n        }\n    }\n\n    public async captureGameScreen(): Promise<ImageData | null> {\n        if (!this.canvas || !this.ctx) {\n            return null;\n        }\n\n        try {\n            const gameCanvas = document.querySelector('canvas');\n            if (!gameCanvas) {\n                return null;\n            }\n\n            // Set canvas size to match game window\n            this.canvas.width = gameCanvas.width;\n            this.canvas.height = gameCanvas.height;\n\n            // Draw game canvas to our canvas\n            this.ctx.drawImage(gameCanvas, 0, 0);\n\n            // Get image data\n            return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n        } catch (error) {\n            console.error('Error capturing game screen:', error);\n            return null;\n        }\n    }\n\n    public findColorMatch(imageData: ImageData, targetColor: RGB, tolerance: number = 5): PixelMatch[] {\n        const matches: PixelMatch[] = [];\n        const data = imageData.data;\n        const width = imageData.width;\n\n        for (let i = 0; i < data.length; i += 4) {\n            const r = data[i];\n            const g = data[i + 1];\n            const b = data[i + 2];\n\n            if (this.isColorMatch({ r, g, b }, targetColor, tolerance)) {\n                const pixelIndex = i / 4;\n                const x = pixelIndex % width;\n                const y = Math.floor(pixelIndex / width);\n                const confidence = this.calculateConfidence({ r, g, b }, targetColor);\n                matches.push({ x, y, confidence });\n            }\n        }\n\n        // Sort by confidence\n        return matches.sort((a, b) => b.confidence - a.confidence);\n    }\n\n    private isColorMatch(color1: RGB, color2: RGB, tolerance: number): boolean {\n        return Math.abs(color1.r - color2.r) <= tolerance &&\n               Math.abs(color1.g - color2.g) <= tolerance &&\n               Math.abs(color1.b - color2.b) <= tolerance;\n    }\n\n    private calculateConfidence(color1: RGB, color2: RGB): number {\n        const rDiff = Math.abs(color1.r - color2.r);\n        const gDiff = Math.abs(color1.g - color2.g);\n        const bDiff = Math.abs(color1.b - color2.b);\n        const maxDiff = 255 * 3;\n        const totalDiff = rDiff + gDiff + bDiff;\n        return 1 - (totalDiff / maxDiff);\n    }\n\n    // Game-specific color detection methods\n    public async findGameElements(): Promise<{[key: string]: PixelMatch[]}> {\n        const imageData = await this.captureGameScreen();\n        if (!imageData) {\n            return {};\n        }\n\n        return {\n            // Common UI elements\n            minimap: this.findColorMatch(imageData, { r: 0, g: 0, b: 0 }, 10), // Black border\n            chatbox: this.findColorMatch(imageData, { r: 65, g: 54, b: 38 }, 10), // Brown background\n            \n            // Game objects\n            chickens: this.findColorMatch(imageData, { r: 255, g: 255, b: 255 }, 15), // White feathers\n            feathers: this.findColorMatch(imageData, { r: 238, g: 238, b: 238 }, 10), // Ground items\n            \n            // Combat elements\n            healthBar: this.findColorMatch(imageData, { r: 255, g: 0, b: 0 }, 10), // Red health\n            attackOptions: this.findColorMatch(imageData, { r: 255, g: 255, b: 0 }, 10), // Yellow text\n        };\n    }\n\n    public async waitForGameElement(elementType: string, timeout: number = 5000): Promise<PixelMatch | null> {\n        const startTime = Date.now();\n        \n        while (Date.now() - startTime < timeout) {\n            const elements = await this.findGameElements();\n            const matches = elements[elementType] || [];\n            \n            if (matches.length > 0) {\n                return matches[0]; // Return the highest confidence match\n            }\n            \n            await new Promise(resolve => setTimeout(resolve, 100)); // Wait 100ms before next check\n        }\n        \n        return null; // Timeout reached\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
